[
["index.html", "Visualisation of biomolecular data Chapter 1 Introduction 1.1 Installation 1.2 Questions 1.3 License 1.4 References", " Visualisation of biomolecular data Laurent Gatto 2018-04-29 Chapter 1 Introduction This Visualisation of biomolecular data course was set up as part of the 2018 edition of the May Institute Computation and statistics for mass spectrometry and proteomics at Northeastern University, Boston MA. It is aimed at people who are already familiar with the R language and syntax, and who would like to get a hands-on introduction to visualisation with a focus on biomolecular data in general, and proteomics in particular. This course is meant to be mostly hands-on, with an intuitive understanding of the underlying techniques. An important aspect of data visualisation is data manipulation, transformation and the format of the data. These topics will be introduced and documented throughout the course. A short URL for this book is http://bit.ly/biomolvis 1.1 Installation A set of packages that are used, either directly or indirectly are provided below. A complete session information with all packages used to compile this document is available at the end. The source code for this document is available on GitHub at https://github.com/lgatto/VisualisingBiomolecularData library(&quot;ggplot2&quot;) library(&quot;MSnbase&quot;) library(&quot;pRolocdata&quot;) library(&quot;pRoloc&quot;) library(&quot;ALL&quot;) library(&quot;MSstatsBioData&quot;) 1.2 Questions For any questions or suggestions, please open an issue. Please do add the output of your session information and, of possible, a reproducible example describing your question or suggestion. 1.3 License This material is licensed under the Creative Commons Attribution-ShareAlike 4.0 License. Some content is inspired by other sources, see the Credit section in the material. 1.4 References Gatto L, Breckels LM, Naake T, Gibb S. Visualization of proteomics data using R and bioconductor. Proteomics. 2015 Apr;15(8):1375-89. doi: 10.1002/pmic.201400392. PMID: 25690415; PMCID: PMC4510819. Key M. A tutorial in displaying mass spectrometry-based proteomic data using heat maps. BMC Bioinformatics. 2012;13 Suppl 16:S10. doi: 10.1186/1471-2105-13-S16-S10. Epub 2012 Nov 5. PMID: 23176119; PMCID: PMC3489527. Gatto L, Christoforou A. Using R and Bioconductor for proteomics data analysis. Biochim Biophys Acta. 2014 Jan;1844(1 Pt A):42-51. doi: 10.1016/j.bbapap.2013.04.032. Epub 2013 May 18. PMID: 23692960. "],
["example-datasets-and-data-manipulation.html", "Chapter 2 Example datasets and data manipulation 2.1 Raw MS data 2.2 The iPRG data 2.3 CRC training data 2.4 ALL data 2.5 Using dplyr for data manipulation", " Chapter 2 Example datasets and data manipulation We will used various datasets throughout the course. These data are briefly described below, and we will explore them through various visualisations later. This section also introduces some techniques to manipulate data and transorm them into different formats. 2.1 Raw MS data Section Using R and Bioconductor for MS-based proteomics shows how to visualise raw mass spectrometry data. The raw data that will be using come from the msdata MSnbase packages. These data will be introduced later. 2.2 The iPRG data iprg &lt;- read.csv(&quot;http://bit.ly/VisBiomedDataIprgCsv&quot;) head(iprg) ## Protein Log2Intensity Run Condition ## 1 sp|D6VTK4|STE2_YEAST 26.81232 JD_06232014_sample1_B.raw Condition1 ## 2 sp|D6VTK4|STE2_YEAST 26.60786 JD_06232014_sample1_C.raw Condition1 ## 3 sp|D6VTK4|STE2_YEAST 26.58301 JD_06232014_sample1-A.raw Condition1 ## 4 sp|D6VTK4|STE2_YEAST 26.83563 JD_06232014_sample2_A.raw Condition2 ## 5 sp|D6VTK4|STE2_YEAST 26.79430 JD_06232014_sample2_B.raw Condition2 ## 6 sp|D6VTK4|STE2_YEAST 26.60863 JD_06232014_sample2_C.raw Condition2 ## BioReplicate Intensity TechReplicate ## 1 1 117845016 B ## 2 1 102273602 C ## 3 1 100526837 A ## 4 2 119765106 A ## 5 2 116382798 B ## 6 2 102328260 C dim(iprg) ## [1] 36321 7 table(iprg$Condition, iprg$TechReplicate) ## ## A B C ## Condition1 3026 3026 3027 ## Condition2 3027 3027 3027 ## Condition3 3027 3027 3027 ## Condition4 3027 3026 3027 Reference: Choi M, Eren-Dogu ZF, Colangelo C, Cottrell J, Hoopmann MR, Kapp EA, Kim S, Lam H, Neubert TA, Palmblad M, Phinney BS, Weintraub ST, MacLean B, Vitek O. ABRF Proteome Informatics Research Group (iPRG) 2015 Study: Detection of Differentially Abundant Proteins in Label-Free Quantitative LC-MS/MS Experiments. J Proteome Res. 2017 Feb 3;16(2):945-957. doi: 10.1021/acs.jproteome.6b00881 Epub 2017 Jan 3. PMID: 27990823. This data is in the so-called long format. In some applications, it is more convenient to have the data in wide format, where rows contain the protein expression data for all samples. Let’s start by simplifying the data to keep only the relevant columns: head(iprg2 &lt;- iprg[, c(1, 3, 6)]) ## Protein Run Intensity ## 1 sp|D6VTK4|STE2_YEAST JD_06232014_sample1_B.raw 117845016 ## 2 sp|D6VTK4|STE2_YEAST JD_06232014_sample1_C.raw 102273602 ## 3 sp|D6VTK4|STE2_YEAST JD_06232014_sample1-A.raw 100526837 ## 4 sp|D6VTK4|STE2_YEAST JD_06232014_sample2_A.raw 119765106 ## 5 sp|D6VTK4|STE2_YEAST JD_06232014_sample2_B.raw 116382798 ## 6 sp|D6VTK4|STE2_YEAST JD_06232014_sample2_C.raw 102328260 We can convert the iPRG into a wide format with tidyr::spread: library(&quot;tidyr&quot;) iprg3 &lt;- spread(iprg2, Run, Intensity) head(iprg3) ## Protein JD_06232014_sample1-A.raw ## 1 sp|D6VTK4|STE2_YEAST 100526837 ## 2 sp|O13297|CET1_YEAST 27598550 ## 3 sp|O13329|FOB1_YEAST 11625198 ## 4 sp|O13539|THP2_YEAST 20606703 ## 5 sp|O13547|CCW14_YEAST 145493943 ## 6 sp|O13563|RPN13_YEAST 75530595 ## JD_06232014_sample1_B.raw JD_06232014_sample1_C.raw ## 1 117845016 102273602 ## 2 27618234 26774670 ## 3 10892143 16948335 ## 4 192490784 175282010 ## 5 156581624 117211277 ## 6 71664672 82193735 ## JD_06232014_sample2_A.raw JD_06232014_sample2_B.raw ## 1 119765106 116382798 ## 2 24114625 26803677 ## 3 9448487 11334921 ## 4 61781078 72052121 ## 5 151407246 126364703 ## 6 62998676 73431260 ## JD_06232014_sample2_C.raw JD_06232014_sample3_A.raw ## 1 102328260 103830944 ## 2 25055912 21977898 ## 3 14304554 19285356 ## 4 62895992 52653164 ## 5 123774524 99222081 ## 6 67612042 75916420 ## JD_06232014_sample3_B.raw JD_06232014_sample3_C.raw ## 1 94660680 96919972 ## 2 25901361 26545544 ## 3 10230925 13985282 ## 4 84856844 63400641 ## 5 113287367 129669642 ## 6 68877388 72632994 ## JD_06232014_sample4-A.raw JD_06232014_sample4_B.raw ## 1 105724288 102150172 ## 2 23860882 26305424 ## 3 8592981 9414560 ## 4 35363603 109094905 ## 5 141404829 132444723 ## 6 57600421 70708409 ## JD_06232014_sample4_C.raw ## 1 87702341 ## 2 26612349 ## 3 12783705 ## 4 63392610 ## 5 117065261 ## 6 69675572 nrow(iprg3) ## [1] 3027 Indeed, we started with length(unique(iprg$Protein)) ## [1] 3027 unique proteins, which corresponds to the number of rows in the new wide dataset. The long format is ideal when using ggplot2, as we will see in a later chapter. The wide format has also advantages. For example, it becomes straighforward to verify if there are proteins that haven’t been quantified in some samples. (k &lt;- which(is.na(iprg3), arr.ind = dim(iprg3))) ## row col ## [1,] 2721 2 ## [2,] 2721 3 ## [3,] 652 12 iprg3[k[, &quot;row&quot;], ] ## Protein JD_06232014_sample1-A.raw ## 2721 sp|Q08236|AVO1_YEAST NA ## 2721.1 sp|Q08236|AVO1_YEAST NA ## 652 sp|P28320|CWC16_YEAST 1108670 ## JD_06232014_sample1_B.raw JD_06232014_sample1_C.raw ## 2721 NA 10989286 ## 2721.1 NA 10989286 ## 652 961273.8 1229085 ## JD_06232014_sample2_A.raw JD_06232014_sample2_B.raw ## 2721 5407419.7 2041424 ## 2721.1 5407419.7 2041424 ## 652 449839.1 1334009 ## JD_06232014_sample2_C.raw JD_06232014_sample3_A.raw ## 2721 13108081 4677052 ## 2721.1 13108081 4677052 ## 652 1633894 1493440 ## JD_06232014_sample3_B.raw JD_06232014_sample3_C.raw ## 2721 10308957 13639794 ## 2721.1 10308957 13639794 ## 652 2205688 2120321 ## JD_06232014_sample4-A.raw JD_06232014_sample4_B.raw ## 2721 10377088.4 2592511 ## 2721.1 10377088.4 2592511 ## 652 757082.7 NA ## JD_06232014_sample4_C.raw ## 2721 10420338 ## 2721.1 10420338 ## 652 1264712 The opposite operation to spread is gather, also from the tidyr package: head(iprg4 &lt;- gather(iprg3, key = Run, value = Intensity, -Protein)) ## Protein Run Intensity ## 1 sp|D6VTK4|STE2_YEAST JD_06232014_sample1-A.raw 100526837 ## 2 sp|O13297|CET1_YEAST JD_06232014_sample1-A.raw 27598550 ## 3 sp|O13329|FOB1_YEAST JD_06232014_sample1-A.raw 11625198 ## 4 sp|O13539|THP2_YEAST JD_06232014_sample1-A.raw 20606703 ## 5 sp|O13547|CCW14_YEAST JD_06232014_sample1-A.raw 145493943 ## 6 sp|O13563|RPN13_YEAST JD_06232014_sample1-A.raw 75530595 The two lond datasets, iprg2 and iprg4 are different due to the missing values shown above. nrow(iprg2) ## [1] 36321 nrow(iprg4) ## [1] 36324 nrow(na.omit(iprg4)) ## [1] 36321 which can be accounted for by removing rows with missing values by setting na.rm = TRUE. head(iprg5 &lt;- gather(iprg3, key = Run, value = Intensity, -Protein, na.rm = TRUE)) ## Protein Run Intensity ## 1 sp|D6VTK4|STE2_YEAST JD_06232014_sample1-A.raw 100526837 ## 2 sp|O13297|CET1_YEAST JD_06232014_sample1-A.raw 27598550 ## 3 sp|O13329|FOB1_YEAST JD_06232014_sample1-A.raw 11625198 ## 4 sp|O13539|THP2_YEAST JD_06232014_sample1-A.raw 20606703 ## 5 sp|O13547|CCW14_YEAST JD_06232014_sample1-A.raw 145493943 ## 6 sp|O13563|RPN13_YEAST JD_06232014_sample1-A.raw 75530595 2.3 CRC training data This dataset comes from the MSstatsBioData package and was generated as follows: library(&quot;MSstats&quot;) library(&quot;MSstatsBioData&quot;) data(SRM_crc_training) Quant &lt;- dataProcess(SRM_crc_training) subjectQuant &lt;- quantification(Quant) It provides quantitative information for 72 proteins, including two standard proteins, AIAG-Bovine and FETUA-Bovine. These proteins were targeted for plasma samples with SRM with isotope labeled reference peptides in order to identify candidate protein biomarker for non-invasive detection of CRC. The training cohort included 100 subjects in control group and 100 subjects with CRC. Each sample for subject was measured in a single injection without technical replicate. The training cohort was analyzed with Skyline. The dataset was already normalized as described in manuscript. User do not need extra normalization. NAs should be considered as censored missing. Two standard proteins can be removed for statistical analysis. Clinical information where added manually thereafter. To load this dataset: crcdf &lt;- read.csv(&quot;http://bit.ly/VisBiomedDataCrcCsv&quot;) crcdf[1:10, 1:3] ## A1AG2 AFM AHSG ## 1 14.23816 16.10302 19.95179 ## 2 15.02411 16.02071 19.71592 ## 3 15.63136 16.14380 19.71085 ## 4 15.40137 16.27642 19.70438 ## 5 16.00316 16.95821 20.42033 ## 6 13.93242 16.52772 19.88985 ## 7 14.34155 16.43029 20.10060 ## 8 13.57086 17.11052 19.93833 ## 9 15.83348 15.88189 18.64270 ## 10 15.37996 16.22621 20.09992 This dataset is in the wide format. It contains the intensity of the proteins in columns 1 to 72 for each of the 200 samples along the rows. Generally, omics datasets contain the features (proteins, transcripts, …) along the rows and the samples along the columns. In columns 73 to 79, we sample metadata. crcdf[1:10, 73:79] ## Sample Group Age Gender Cancer_stage Tumour_location Sub_group ## 1 P1A10 CRC 60 female 1 colon CRC ## 2 P1A2 CRC 70 male 1 rectum CRC ## 3 P1A4 CRC 65 male 1 rectum CRC ## 4 P1A6 CRC 65 female 4 colon CRC ## 5 P1B12 CRC 62 female 3 colon CRC ## 6 P1B2 CRC 55 male 2 colon CRC ## 7 P1B3 CRC 61 male 2 rectum CRC ## 8 P1B6 CRC 52 male 4 rectum CRC ## 9 P1B9 CRC 89 female 4 colon CRC ## 10 P1C11 CRC 81 male 1 rectum CRC A widely used data structure for omics data follows the convention described in the figure below: An eSet-type of expression data container This typical omics data structure, as defined by the eSet class in the Bioconductor Biobase package, is represented below. It’s main features are An assay data slot containing the quantitative omics data (expression data), stored as a matrix and accessible with exprs. Features defined along the rows and samples along the columns. A sample metadata slot containing sample co-variates, stored as an annotated data.frame and accessible with pData. This data frame is stored with rows representing samples and sample covariate along the columns, and its rows match the expression data columns exactly. A feature metadata slot containing feature co-variates, stored as an annotated data.frame and accessible with fData. This dataframe’s rows match the expression data rows exactly. The coordinated nature of the high throughput data guarantees that the dimensions of the different slots will always match (i.e the columns in the expression data and then rows in the sample metadata, as well as the rows in the expression data and feature metadata) during data manipulation. The metadata slots can grow additional co-variates (columns) without affecting the other structures. Below, we show how to transform the crc dataset into an MSnSet (implementing the data structure above for quantitative proteomics data) using the readMSnSet2 function. library(&quot;MSnbase&quot;) i &lt;- 1:72 ## expression columns e &lt;- t(crcdf[, i]) ## expression data colnames(e) &lt;- 1:200 crc &lt;- readMSnSet2(data.frame(e), e = 1:200) pd &lt;- crcdf[, -i] rownames(pd) &lt;- paste0(&quot;X&quot;, rownames(pd)) pData(crc) &lt;- pd crc ## MSnSet (storageMode: lockedEnvironment) ## assayData: 72 features, 200 samples ## element names: exprs ## protocolData: none ## phenoData ## sampleNames: X1 X2 ... X200 (200 total) ## varLabels: Sample Group ... Sub_group (7 total) ## varMetadata: labelDescription ## featureData: none ## experimentData: use &#39;experimentData(object)&#39; ## Annotation: ## - - - Processing information - - - ## MSnbase version: 2.5.14 Or load it direcly: download.file(&quot;http://bit.ly/VisBiomedDataCrcMSnSet&quot;, &quot;./data/crc.rda&quot;) load(&quot;./data/crc.rda&quot;) crc ## MSnSet (storageMode: lockedEnvironment) ## assayData: 72 features, 200 samples ## element names: exprs ## protocolData: none ## phenoData ## sampleNames: X1 X2 ... X200 (200 total) ## varLabels: Sample Group ... Sub_group (7 total) ## varMetadata: labelDescription ## featureData: none ## experimentData: use &#39;experimentData(object)&#39; ## Annotation: ## - - - Processing information - - - ## MSnbase version: 2.5.14 Reference: See Surinova, S. et al. (2015) Prediction of colorectal cancer diagnosis based on circulating plasma proteins. EMBO Mol. Med., 7, 1166–1178 for details. 2.4 ALL data library(&quot;ALL&quot;) data(ALL) ALL ## ExpressionSet (storageMode: lockedEnvironment) ## assayData: 12625 features, 128 samples ## element names: exprs ## protocolData: none ## phenoData ## sampleNames: 01005 01010 ... LAL4 (128 total) ## varLabels: cod diagnosis ... date last seen (21 total) ## varMetadata: labelDescription ## featureData: none ## experimentData: use &#39;experimentData(object)&#39; ## pubMedIds: 14684422 16243790 ## Annotation: hgu95av2 From the documentation page: The Acute Lymphoblastic Leukemia Data from the Ritz Laboratory consist of microarrays from 128 different individuals with acute lymphoblastic leukemia (ALL). A number of additional covariates are available. The data have been normalized (using rma) and it is the jointly normalized data that are available here. The ALL data is of class ExpressionSet, which implements the data structure above for microarray expression data. Reference: Sabina Chiaretti, Xiaochun Li, Robert Gentleman, Antonella Vitale, Marco Vignetti, Franco Mandelli, Jerome Ritz, and Robin Foa Gene expression profile of adult T-cell acute lymphocytic leukemia identifies distinct subsets of patients with different response to therapy and survival. Blood, 1 April 2004, Vol. 103, No. 7. 2.5 Using dplyr for data manipulation "],
["exploring-and-visualising-biomolecular-data.html", "Chapter 3 Exploring and visualising biomolecular data", " Chapter 3 Exploring and visualising biomolecular data "],
["plotting-in-r.html", "Chapter 4 Plotting in R 4.1 Base graphics 4.2 Plotting with ggplot2 4.3 References", " Chapter 4 Plotting in R 4.1 Base graphics 4.2 Plotting with ggplot2 Base graphics uses a canvas model a series of instructions that sequentially fill the plotting canvas. While this model is very useful to build plots bits by bits bottom up, which is useful in some cases, it has some clear drawback: Layout choices have to be made without global overview over what may still be coming. Different functions for different plot types with different interfaces. No standard data input. Many routine tasks require a lot of boilerplate code. No concept of facets/lattices/viewports. Poor default colours. The ggplot2 package implements a grammar of graphics. Users describe what and how to visualise data and the package then generates the figure. The components of ggplot2’s of graphics are A tidy dataset A choice of geometric objects that servers as the visual representation of the data - for instance, points, lines, rectangles, contours. A description of how the variables in the data are mapped to visual properties (aesthetics) or the geometric objects, and an associated scale (e.g. linear, logarithmic, polar) A statistical summarisation rule A coordinate system. A facet specification, i.e. the use of several plots to look at the same data. Fist of all, we need to load the ggplot2 package and load the iprg data. library(&quot;ggplot2&quot;) iprg &lt;- read.csv(&quot;http://bit.ly/VisBiomedDataIprgCsv&quot;) ggplot graphics are built step by step by adding new elements. To build a ggplot we need to: bind the plot to a specific data frame using the data argument ggplot(data = iprg) define aesthetics (aes), by selecting the variables to be plotted and the variables to define the presentation such as plotting size, shape color, etc. ggplot(data = iprg, aes(x = Run, y = Log2Intensity)) add geoms – graphical representation of the data in the plot (points, lines, bars). To add a geom to the plot use + operator ggplot(data = iprg, aes(x = Run, y = Log2Intensity)) + geom_boxplot() See the documentation page to explore the many available geoms. The + in the ggplot2 package is particularly useful because it allows you to modify existing ggplot objects. This means you can easily set up plot “templates” and conveniently explore different types of plots, so the above plot can also be generated with code like this: ## Assign plot to a variable ints_plot &lt;- ggplot(data = iprg, aes(x = Run, y = Log2Intensity)) ## Draw the plot ints_plot + geom_boxplot() Notes: Anything you put in the ggplot() function can be seen by any geom layers that you add (i.e., these are universal plot settings). This includes the x and y axis you set up in aes(). You can also specify aesthetics for a given geom independently of the aesthetics defined globally in the ggplot() function. The + sign used to add layers must be placed at the end of each line containing a layer. If, instead, the + sign is added in the line before the other layer, ggplot2 will not add the new layer and will return an error message. 4.3 References ggplot2 extensions - gallery ggplot2 webpage and documentation ggplot2: Elegant Graphics for Data Analysis book (source of the book available for free here). "],
["using-r-and-bioconductor-for-ms-based-proteomics.html", "Chapter 5 Using R and Bioconductor for MS-based proteomics", " Chapter 5 Using R and Bioconductor for MS-based proteomics "],
["tools-and-plots.html", "Chapter 6 Tools and plots 6.1 Transformations 6.2 Correlation 6.3 Pairs 6.4 Volcano plots 6.5 Visualising intersections: Venn, Euler, upset plots 6.6 Unsupervised learning 6.7 Heatmaps", " Chapter 6 Tools and plots 6.1 Transformations 6.2 Correlation 6.3 Pairs 6.4 Volcano plots 6.5 Visualising intersections: Venn, Euler, upset plots 6.6 Unsupervised learning In unsupervised learning (UML), no labels are provided, and the learning algorithm focuses solely on detecting structure in unlabelled input data. One generally differentiates between Clustering, where the goal is to find homogeneous subgroups within the data; the grouping is based on distance between observations. Dimensionality reduction, where the goal is to identify patterns in the features of the data. Dimensionality reduction is often used to facilitate visualisation of the data, as well as a pre-processing method before supervised learning. UML presents specific challenges and benefits: there is no single goal in UML there is generally much more unlabelled data available than labelled data. Unsupervised learning techniques are paramount for exploratory data analysis and visualisation. 6.6.1 Dimensionality reduction (PCA) 6.6.2 K-means clustering 6.6.3 Hierarchical clustering 6.7 Heatmaps See Key M. A tutorial in displaying mass spectrometry-based proteomic data using heat maps. BMC Bioinformatics. 2012;13 Suppl 16:S10. doi: 10.1186/1471-2105-13-S16-S10. Epub 2012 Nov 5. Review. PMID: 23176119; PMCID: PMC3489527. 6.7.1 Heatmap components 6.7.2 Data reordering 6.7.3 Distance 6.7.4 Clustering (agglomeration) 6.7.5 Image representation 6.7.6 Colour mapping 6.7.7 Colour palette 6.7.8 "],
["interactive-visualisation.html", "Chapter 7 Interactive visualisation", " Chapter 7 Interactive visualisation "],
["session-information.html", "Chapter 8 Session information", " Chapter 8 Session information The session information below documents the packages and versions used to generate this material. sessionInfo() ## R Under development (unstable) (2018-04-02 r74505) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 14.04.5 LTS ## ## Matrix products: default ## BLAS: /usr/lib/atlas-base/atlas/libblas.so.3.0 ## LAPACK: /usr/lib/lapack/liblapack.so.3.0 ## ## locale: ## [1] LC_CTYPE=en_GB.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_GB.UTF-8 LC_COLLATE=en_GB.UTF-8 ## [5] LC_MONETARY=en_GB.UTF-8 LC_MESSAGES=en_GB.UTF-8 ## [7] LC_PAPER=en_GB.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats4 parallel stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] tidyr_0.8.0 MSstatsBioData_1.1.0 ALL_1.21.0 ## [4] pRoloc_1.19.4 MLInterfaces_1.59.1 cluster_2.0.7 ## [7] annotate_1.57.3 XML_3.98-1.10 AnnotationDbi_1.41.4 ## [10] IRanges_2.13.28 S4Vectors_0.17.41 pRolocdata_1.17.3 ## [13] MSnbase_2.5.14 ProtGenerics_1.11.0 BiocParallel_1.13.3 ## [16] mzR_2.13.6 Rcpp_0.12.16 Biobase_2.39.2 ## [19] BiocGenerics_0.25.3 ggplot2_2.2.1 readr_1.1.1 ## [22] BiocStyle_2.7.8 ## ## loaded via a namespace (and not attached): ## [1] backports_1.1.2 plyr_1.8.4 igraph_1.2.1 ## [4] lazyeval_0.2.1 splines_3.6.0 ggvis_0.4.3 ## [7] crosstalk_1.0.0 digest_0.6.15 foreach_1.4.4 ## [10] BiocInstaller_1.29.6 htmltools_0.3.6 viridis_0.5.1 ## [13] gdata_2.18.0 magrittr_1.5 memoise_1.1.0 ## [16] doParallel_1.0.11 sfsmisc_1.1-2 limma_3.35.14 ## [19] recipes_0.1.2 gower_0.1.2 rda_1.0.2-2 ## [22] dimRed_0.1.0 lpSolve_5.6.13 prettyunits_1.0.2 ## [25] colorspace_1.3-2 blob_1.1.1 xfun_0.1 ## [28] dplyr_0.7.4.9003 RCurl_1.95-4.10 hexbin_1.27.2 ## [31] genefilter_1.61.1 bindr_0.1.1 impute_1.53.0 ## [34] DRR_0.0.3 survival_2.41-3 iterators_1.0.9 ## [37] glue_1.2.0 gtable_0.2.0 ipred_0.9-6 ## [40] zlibbioc_1.25.0 ddalpha_1.3.1.1 kernlab_0.9-25 ## [43] prabclus_2.2-6 DEoptimR_1.0-8 scales_0.5.0 ## [46] vsn_3.47.1 mvtnorm_1.0-7 DBI_0.8 ## [49] viridisLite_0.3.0 xtable_1.8-2 progress_1.1.2 ## [52] foreign_0.8-70 bit_1.1-12 proxy_0.4-22 ## [55] mclust_5.4 preprocessCore_1.41.0 lava_1.6.1 ## [58] prodlim_1.6.1 sampling_2.8 htmlwidgets_1.0 ## [61] httr_1.3.1 threejs_0.3.1 FNN_1.1 ## [64] RColorBrewer_1.1-2 fpc_2.1-11 modeltools_0.2-21 ## [67] pkgconfig_2.0.1 flexmix_2.3-14 nnet_7.3-12 ## [70] caret_6.0-78 labeling_0.3 tidyselect_0.2.4 ## [73] rlang_0.2.0 reshape2_1.4.3 munsell_0.4.3 ## [76] mlbench_2.1-1 tools_3.6.0 msdata_0.19.4 ## [79] RSQLite_2.1.0 pls_2.6-0 broom_0.4.4 ## [82] evaluate_0.10.1 stringr_1.3.0 mzID_1.17.0 ## [85] yaml_2.1.18 ModelMetrics_1.1.0 knitr_1.20 ## [88] bit64_0.9-7 robustbase_0.92-8 randomForest_4.6-14 ## [91] purrr_0.2.4 dendextend_1.7.0 bindrcpp_0.2.2.9000 ## [94] nlme_3.1-136 whisker_0.3-2 mime_0.5 ## [97] RcppRoll_0.2.2 biomaRt_2.35.13 compiler_3.6.0 ## [100] rstudioapi_0.7 ## [ reached getOption(&quot;max.print&quot;) -- omitted 37 entries ] "]
]
